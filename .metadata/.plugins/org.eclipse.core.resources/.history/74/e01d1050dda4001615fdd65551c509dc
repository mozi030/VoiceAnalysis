package NeuralNetwork;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;

public class NeuralNetwork {
	final static public int inputNum = 500;
	final static public ArrayList<String> outputs = new ArrayList<String>(
			Arrays.asList("down", "jump", "left", "move", "right", "shoot", "speedup", "up"));
	public static Node allNodes[][];

	final static public int hiddenLayerNum = 2;
	final static public int affectRange = 5;
	final static public float weightInitialValue = 0.001f;
	final static public float learningRate = 0.3f;

	public NeuralNetwork() throws Exception {
		allNodes = new Node[hiddenLayerNum + 2][];
		allNodes[0] = new Node[inputNum];
		// first layer, the input layer
		for (int j = 0; j < inputNum; j++) {
			allNodes[0][j] = new Node();
			allNodes[0][j].lastNodeIndexAndWeight = null;
			int begin = j - affectRange / 2;
			if (begin < 0) {
				begin = 0;
			}
			int end = j + affectRange / 2;
			if (end >= inputNum) {
				end = inputNum - 1;
			}
			if (end < begin) {
				throw new Exception("end < begin");
			}
			allNodes[0][j].nextNodeIndexAndWeight = new HashMap<>();
			for (int k = begin; k <= end; k++) {
				allNodes[0][j].nextNodeIndexAndWeight.put(k, weightInitialValue);
			}
		}

		// middle layers, the hidden layers
		for (int i = 1; i <= hiddenLayerNum; i++) {
			allNodes[i] = new Node[inputNum];
			for (int j = 0; j < inputNum; j++) {
				allNodes[i][j] = new Node();
				int begin = j - affectRange / 2;
				if (begin < 0) {
					begin = 0;
				}
				int end = j + affectRange / 2;
				if (end >= inputNum) {
					end = inputNum - 1;
				}
				if (end < begin) {
					throw new Exception("end < begin");
				}
				allNodes[i][j].lastNodeIndexAndWeight = new HashMap<>();
				for (int k = begin; k <= end; k++) {
					allNodes[i][j].lastNodeIndexAndWeight.put(k, weightInitialValue);
				}
				allNodes[i][j].nextNodeIndexAndWeight = new HashMap<>();
				if (i != hiddenLayerNum) {
					for (int k = begin; k <= end; k++) {
						allNodes[i][j].nextNodeIndexAndWeight.put(k, weightInitialValue);
					}
				} else {
					for (int k = 0; k < outputs.size(); k++) {
						allNodes[i][j].nextNodeIndexAndWeight.put(k, weightInitialValue);
					}
				}
				allNodes[i][j].cita = weightInitialValue;
			}
		}
		// last layer, the output layer
		allNodes[hiddenLayerNum + 1] = new Node[outputs.size()];
		for (int j = 0; j < outputs.size(); j++) {
			allNodes[hiddenLayerNum + 1][j] = new Node();
			allNodes[hiddenLayerNum + 1][j].nextNodeIndexAndWeight = null;
			allNodes[hiddenLayerNum + 1][j].lastNodeIndexAndWeight = new HashMap<>();
			for (int k = 0; k < inputNum; k++) {
				allNodes[hiddenLayerNum + 1][j].lastNodeIndexAndWeight.put(k, weightInitialValue);
			}
			allNodes[hiddenLayerNum + 1][j].cita = weightInitialValue;
		}
	}

	public void TrainNetwork(ArrayList<Data> allTrainData) {
		int index = 0;
		// int count = 0;
		while (true) {
			Data currentData = allTrainData.get(index);
			for (int i = 0; i < inputNum; i++) {
				allNodes[0][i].data = currentData.dataList[i];
			}
			float evaluatedValue = ForwardFeed();

			System.out.println(
					"evaluatedValue: " + evaluatedValue + "  error: " + Math.abs(evaluatedValue - currentData.result));

			BackPropagation(currentData.result);

			index = (index + 1) % allTrainData.size();
		}
	}

	public void BackPropagation(float realResult) {
		float evaluatedValue = allNodes[hiddenLayerNum + 1][0].data;
		allNodes[hiddenLayerNum + 1][0].error = evaluatedValue * (1 - evaluatedValue) * (realResult - evaluatedValue);
		for (Map.Entry<Integer, Float> entry : allNodes[hiddenLayerNum + 1][0].lastNodeIndexAndWeight.entrySet()) {
			int lastIndex = entry.getKey();
			float lastWeight = entry.getValue();
			float newWeight = lastWeight
					+ learningRate * allNodes[hiddenLayerNum + 1][0].error * allNodes[hiddenLayerNum][lastIndex].data;
			allNodes[hiddenLayerNum + 1][0].lastNodeIndexAndWeight.put(lastIndex, newWeight);
			allNodes[hiddenLayerNum][lastIndex].nextNodeIndexAndWeight.put(0, newWeight);
		}
		allNodes[hiddenLayerNum + 1][0].cita += learningRate * allNodes[hiddenLayerNum + 1][0].error;

		for (int i = hiddenLayerNum; i >= 1; i--) {
			for (int j = 0; j < inputNum; j++) {
				float o = allNodes[i][j].data;
				float temp = 0;
				for (Map.Entry<Integer, Float> entry : allNodes[i][j].nextNodeIndexAndWeight.entrySet()) {
					int nextIndex = entry.getKey();
					float nextWeight = entry.getValue();
					temp += nextWeight * allNodes[i + 1][nextIndex].data;
				}
				allNodes[i][j].error = o * (1 - o) * temp;

				for (Map.Entry<Integer, Float> entry : allNodes[i][j].lastNodeIndexAndWeight.entrySet()) {
					int lastIndex = entry.getKey();
					float lastWeight = entry.getValue();
					float newWeight = lastWeight
							+ learningRate * allNodes[i][j].error * allNodes[i - 1][lastIndex].data;
					allNodes[i][j].lastNodeIndexAndWeight.put(lastIndex, newWeight);
					allNodes[i - 1][lastIndex].nextNodeIndexAndWeight.put(j, newWeight);
				}
				allNodes[i][j].cita += learningRate * allNodes[i][j].error;
			}
		}
	}

	public float ForwardFeed() {
		for (int i = 1; i <= hiddenLayerNum; i++) {
			for (int j = 0; j < inputNum; j++) {
				float temp = 0;
				for (Map.Entry<Integer, Float> entry : allNodes[i][j].lastNodeIndexAndWeight.entrySet()) {
					int lastIndex = entry.getKey();
					float lastWeight = entry.getValue();
					temp += lastWeight * allNodes[i - 1][lastIndex].data;
				}
				temp += allNodes[i][j].cita;
				allNodes[i][j].data = evaluate(temp);
			}
		}
		float temp = 0;
		int maxIndex = -1;
		int maxEvaluation = -1;
		for (int j = 0; j < outputs.size(); j++) {
			for (Map.Entry<Integer, Float> entry : allNodes[hiddenLayerNum + 1][j].lastNodeIndexAndWeight.entrySet()) {
				int lastIndex = entry.getKey();
				float lastWeight = entry.getValue();
				temp += lastWeight * allNodes[hiddenLayerNum][lastIndex].data;
			}
			temp += allNodes[hiddenLayerNum + 1][j].cita;
			allNodes[hiddenLayerNum + 1][j].data = evaluate(temp);
			if (maxEvaluation < allNodes[hiddenLayerNum + 1][j].data) {
				maxEvaluation = allNodes[hiddenLayerNum + 1][j].data;
				maxIndex = j;
			}
		}
		return allNodes[hiddenLayerNum + 1][0].data;
	}

	public static float evaluate(float a) {
		return (float) (1.0 / (1 + Math.exp(-a)));
	}
}
